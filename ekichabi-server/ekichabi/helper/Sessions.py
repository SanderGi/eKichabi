import datetime
import random
import json

from django.conf import settings

from ekichabi.helper.Logs import log_render_screen_content, log_user_input, log_return_home_screen, log_press_back_button, log_end_screen
from ekichabi.helper.Utils import bcolors, save_pickled, load_pickled

from ekichabi.screens.Buttons import back_button, home_button, exit_button
from ekichabi.screens.base_screens.BaseScreen import BaseScreen

redis = getattr(settings, 'REDIS')


class Session:

    def __init__(self, start_screen, session_id, phone_number,
                 inputs=[], rand=None, created=None, data={}):

        # initially, the history only contains the home screen
        self.history = [start_screen]

        # session id and phone number
        self.session_id = session_id
        self.phone_number = phone_number

        # save randomly generated 100 entries to show to user
        # need to save this because we want to show a consistent set of options
        self.rand100 = rand or random.sample(
            range(10000), 100)

        # allow screens (e.g. search screens) to save session data in a dict
        self.data = data

        # save when the initial session is created for logging purposes
        self.created = created or datetime.datetime.now().strftime(
            '%m/%d/%Y, %H:%M:%S')

        # restore the previous user's inputs from session (setting logging temporarily to false to avoid redundant logs)
        self.islogging = False
        self.inputs = []
        for input in inputs:
            self.process_user_input(input)
        self.islogging = True

    def render_screen_content(self, context=None):
        """ Render latest screen's content """
        log_render_screen_content(self.session_info(), self.current_screen)
        return self.current_screen.render(session=self, context=context)

    def process_user_input(self, input, context=None):
        """ Process user input and generate the next screen based on the input. Returns True if user quit session"""
        # if the user inputs nothing, directly ignore
        if len(input) == 0:
            return False

        # if the user presses home button
        elif input == home_button:
            self.inputs = []
            self.history = [self.history[0]]
            log_return_home_screen(self.session_info())
            return False

        # if the user presses back button
        elif input == back_button:
            if not len(self.history) > 1:
                return
            self.inputs.append(input)
            del self.history[-1]
            log_press_back_button(self.session_info())
            return False

        elif input == exit_button:
            self.history.append(BaseScreen("Kwaheri!"))
            log_end_screen(self.session_info())
            redis.delete(self.session_id)
            return True

        # if there's no next screen, ignore inputs that don't go back
        elif not self.current_screen.has_next(self):
            return False
        
        else:
            # get next screen generated by user's input
            new_screen = self.current_screen.input(
                input, session=self, context=context)

            # if next screen needs to be ommitted from history, we don't save the input
            if not new_screen.ommitfromhistory:
                self.inputs.append(input)

            # if next screen is an intermediate screen, we set it to be the next screen after
            while new_screen.press_next is not None:
                new_screen = new_screen.input(
                    input=new_screen.press_next, session=self, context=context)

            # append the new screen to history
            self.history.append(new_screen)

            # log user input
            log_user_input(self.session_info(), input)
            return False

    @classmethod
    def get_session(cls, ussd, start_screen):
        """ Retrive or construct new session based on the user's ussd input """
        session_id = ussd.session_id
        phone_number = ussd.phone_number

        if redis.exists(session_id):
            # if session id already exists in cache, construct session based on previous cached session
            cached_session = json.loads(redis.get(session_id))
            previous_inputs = cached_session["inputs"]
            rand = cached_session["rand"]
            created = cached_session["created"]
            data = load_pickled(cached_session["data"])
            session = Session(start_screen, session_id,
                              phone_number, previous_inputs, rand, created, data)
            print(bcolors.OKGREEN + 'Session found. Session id:',
                  ussd.session_id + bcolors.ENDC)

        else:
            # if session id doesn't exist in cache, construct new session
            session = Session(start_screen, session_id, phone_number)
            print(bcolors.OKGREEN + 'Session not found. Creating new session. Session id: ',
                  ussd.session_id + bcolors.ENDC)

        return session

    def save_session(self):
        """ Save session in cache for future user inputs """
        redis.set(self.session_id, json.dumps({
            "inputs": self.inputs,
            "rand": self.rand100,
            "created": self.created,
            "data": save_pickled(self.data)
        }), ex=180)

    def session_info(self):
        """ Session info for logging purposes """
        return {'id': self.session_id,
                'number': self.phone_number,
                'created': self.created,
                'islogging': self.islogging}

    @classmethod
    def is_new_session(cls, session_id):
        """ Whether the session is a new session in the cache """
        return redis.exists(session_id)

    @property
    def current_screen(self):
        """ Current screen based on the latest user input """
        return self.history[-1]
